# @format

# vvvvvv
# 文件说明：
# No.[1], 本文件是 clang-format 的配置文件，仅用于格式化 C++ 代码（未定义与 C++ 无关的设置）。
# No.[2], 本文件中的配置项是基于 https://clang-format.netlify.app/BasedOnStyle/ 列出的配置项进行修改的（其中已经声明为 弃置 的项没有在此定义）。
# No.[3], 本文件配置在 Vs Code 中使用 MSYS2 Llvm clang-format.exe（版本：17.0.6 ）中测试通过。
# No.[4], 为了方便阅读，本文件中的配置项是按照 https://clang-format.netlify.app/BasedOnStyle/ 的配置项顺序进行排列的。
# No.[5], 为了方便阅读，本文件中的每一项配置项均以 vvvvvv 开头，^^^^^^ 结尾，中间是配置项的说明和配置值，包括正在阅读的 文件说明 。

# * 最后修改日期：2024-02-15 *
# * 最后修改人：威年 *
#
# ^^^^^^

# vvvvvv
# No.[1], BasedOnStyle (string)
# 用于配置中未特别设置的所有选项的样式。用于配置中未特别设置的所有选项的样式。
# 此选项仅在 clang-format 配置中支持（在 -style='{...}' 和 .clang-format 文件）。
# 可能的值：
# LLVM: 一种符合 LLVM代码规范 的样式
# Google: 一种符合 Google C++风格指南 的样式
# Chromium: 一种符合 Chromium风格指南 的样式
# Mozilla: 一种符合 Mozilla风格指南 的样式
# WebKit: 一种符合 WebKit风格指南 的样式
# Microsoft: 一种符合 Microsoft风格指南 的样式
# GNU: 一种符合 GNU代码规范 的样式
# InheritParentConfig: 不是真正的样式，但允许使用来自父目录的 .clang-format 文件(如果没有父目录，则为其父目录)。如果没有找到父文件，它会退回到 fallback 样式，并将更改应用到该样式。使用这个选项，您可以覆盖子目录的主样式的某些部分。这也可以通过命令行实现，例如：--style={BasedOnStyle: InheritParentConfig, ColumnLimit: 20}
# None: 不使用, 即自动配置, 也就是本文件中的自定义内容

BasedOnStyle: None
# ^^^^^^

# vvvvvv
# No.[2], AccessModifierOffset (int)
# 用于配置访问修饰符的缩进。如果为-1，则使用 IndentWidth 的值。

AccessModifierOffset: -4
# ^^^^^^

# vvvvvv
# No.[3], AlignAfterOpenBracket (BracketAlignmentStyle)
# 如果为 true，则在左大括号后对齐。如果为 false，则在左大括号前对齐。
# 这适用于圆括号、尖括号和方括号。
# 可能的值：
# Align: 将左括号中的参数对齐。
# DontAlign: 不要对齐，而是使用 ContinuationIndentWidth。
# AlwaysBreak: 如果参数不适合在一行中，则始终在左括号后中断。

AlignAfterOpenBracket: Align
# ^^^^^^

# vvvvvv
# No.[4], AlignArrayOfStructures (ArrayInitializerAlignmentStyle)
# 如果不是 None，则在对结构数组使用初始化时，会将字段对齐到列中。
# 可能的值：
# Left: 将字段对齐到列中。
# Right: 将字段对齐到列中。
# None: 不要对齐。

AlignArrayOfStructures: Left
# ^^^^^^

# vvvvvv
# No.[5], AlignConsecutiveAssignments (AlignConsecutiveStyle)
# 对齐连续的赋值。
# 可能的值：
# None: 不要对齐。
# Consecutive: 对齐连续的赋值。
# AcrossEmptyLines: 对齐连续的赋值，即使它们之间有空行。
# AcrossComments: 对齐连续的赋值，即使它们之间有注释。
# AcrossEmptyLinesAndComments: 对齐连续的赋值，即使它们之间有空行或注释。

AlignConsecutiveAssignments: Consecutive
# ^^^^^^

# vvvvvv
# No.[6], AlignConsecutiveBitFields (AlignConsecutiveStyle)
# 对齐连续位字段的样式。
# 可能的值：
# None: 不要对齐。
# Consecutive: 对齐连续的位字段。
# AcrossEmptyLines: 对齐连续的位字段，即使它们之间有空行。
# AcrossComments: 对齐连续的位字段，即使它们之间有注释。
# AcrossEmptyLinesAndComments: 对齐连续的位字段，即使它们之间有空行或注释。

AlignConsecutiveBitFields: Consecutive
# ^^^^^^

# vvvvvv
# No.[7], AlignConsecutiveDeclarations (AlignConsecutiveStyle)
# 对齐连续的声明。
# 可能的值：
# None: 不要对齐。
# Consecutive: 对齐连续的声明。
# AcrossEmptyLines: 对齐连续的声明，即使它们之间有空行。
# AcrossComments: 对齐连续的声明，即使它们之间有注释。
# AcrossEmptyLinesAndComments: 对齐连续的声明，即使它们之间有空行或注释。

AlignConsecutiveDeclarations: Consecutive
# ^^^^^^

# vvvvvv
# No.[8], AlignConsecutiveMacros (AlignConsecutiveStyle)
# 对齐连续的宏。
# 可能的值：
# None: 不要对齐。
# Consecutive: 对齐连续的宏。
# AcrossEmptyLines: 对齐连续的宏，即使它们之间有空行。
# AcrossComments: 对齐连续的宏，即使它们之间有注释。
# AcrossEmptyLinesAndComments: 对齐连续的宏，即使它们之间有空行或注释。

AlignConsecutiveMacros: Consecutive
# ^^^^^^

# vvvvvv
# No.[9], AlignEscapedNewlines (EscapedNewlineAlignmentStyle)
# 对齐转义的换行符。
# 可能的值：
# Left: 将转义的换行符对齐到左边。
# Right: 将转义的换行符对齐到右边。
# DontAlign: 不要对齐。

AlignEscapedNewlines: Left
# ^^^^^^

# vvvvvv
# No.[10], AlignOperands (OperandAlignmentStyle)
# 对齐操作数。
# 可能的值：
# Align: 对齐操作数。
# DontAlign: 不要对齐操作数。
# AlignAfterOperator: 在操作符后对齐操作数。

AlignOperands: AlignAfterOperator
# ^^^^^^

# vvvvvv
# No.[11], AlignTrailingComments (Boolean)
# 如果为 true，则对齐尾注释。

AlignTrailingComments: true
# ^^^^^^

# vvvvvv
# No.[12], AllowAllArgumentsOnNextLine (Boolean)
# 如果为 true，则允许所有参数在下一行，即使 BinPackArguments 为 false 。
# 如果为 false，则在左括号后换行，即使 BinPackArguments 为 false 。

AllowAllArgumentsOnNextLine: false
# ^^^^^^

# vvvvvv
# No.[13], AllowAllParametersOfDeclarationOnNextLine (Boolean)
# 如果为 true，则允许所有声明的参数在下一行，即使 BinPackParameters 为 false 。
# 如果为 false，则在左括号后换行，即使 BinPackParameters 为 false 。

AllowAllParametersOfDeclarationOnNextLine: false
# ^^^^^^

# vvvvvv
# No.[14], AllowShortBlocksOnASingleLine (ShortBlockStyle)
# 依赖于值，while (true) {continue; 可以放在一行上。
# 可能的值：
# Never: 不要将短块放在一行上。
# Empty: 只有空块可以放在一行上。
# Always: 总是将短块放在一行上。

AllowShortBlocksOnASingleLine: Empty
# ^^^^^^

# vvvvvv
# No.[15], AllowShortCaseLabelsOnASingleLine (Boolean)
# 如果为 true，则允许短 case 标签在一行上。

AllowShortCaseLabelsOnASingleLine: false
# ^^^^^^

# vvvvvv
# No.[16], AllowShortEnumsOnASingleLine (Boolean)
# 如果为 true，则允许短枚举在一行上。

AllowShortEnumsOnASingleLine: false
# ^^^^^^

# vvvvvv
# No.[17], AllowShortFunctionsOnASingleLine (ShortFunctionStyle)
# 根据值，int f() { return 0; } 可以放在一行上。
# 可能的值：
# None: 不要将短函数放在一行上。
# Inline: 只有内联函数可以放在一行上。
# Empty: 只有空函数可以放在一行上。
# All: 所有函数都可以放在一行上。
# InlineOnly: 只有内联函数可以放在一行上。

AllowShortFunctionsOnASingleLine: Empty
# ^^^^^^

# vvvvvv
# No.[18], AllowShortIfStatementsOnASingleLine (ShortIfStyle)
# 根据值，if (true) continue; 可以放在一行上。
# 可能的值：
# Never: 不要将短 if 语句放在一行上。
# WithoutElse: 只有没有 else 的 if 语句可以放在一行上。
# OnlyFirstIf: 只有第一个 if 语句可以放在一行上。
# AllIfsAndElse: 所有 if 语句和 else 语句都可以放在一行上。

AllowShortIfStatementsOnASingleLine: Never
# ^^^^^^

# vvvvvv
# No.[19], AllowShortLambdasOnASingleLine (ShortLambdaStyle)
# 根据值，auto f = [](int x) { return x; } 可以放在一行上。
# 可能的值：
# None: 不要将短 lambda 放在一行上。
# Inline: 只有内联 lambda 可以放在一行上。
# Empty: 只有空 lambda 可以放在一行上。
# All: 所有 lambda 都可以放在一行上。

AllowShortLambdasOnASingleLine: Empty
# ^^^^^^

# vvvvvv
# No.[20], AllowShortLoopsOnASingleLine (Boolean)
# 如果为 true，则允许短循环在一行上。

AllowShortLoopsOnASingleLine: false
# ^^^^^^

# vvvvvv
# No.[21], AlwaysBreakAfterReturnType (ReturnTypeBreakingStyle)
# 函数声明返回要使用的类型中断样式。
# 可能的值：
# None: 返回类型后自动中断。PenaltyReturnTypeOnItsOwnLine 被考虑在内。
# All: 总是在返回类型后中断。
# TopLevel: 总是在顶级函数的返回类型之后中断。
# AllDefinitions: 总是在函数定义的返回类型之后中断。
# TopLevelDefinitions: 总是在顶级定义的返回类型之后中断。

AlwaysBreakAfterReturnType: None
# ^^^^^^

# vvvvvv
# No.[22], AlwaysBreakBeforeMultilineStrings (Boolean)
# 如果为 true，则始终在多行字符串之前中断。
# 这个标志是为了使文件中有多个多行字符串的情况看起来更一致。因此，只有在此时包装字符串导致从行开始的 ContinuationIndentWidth 空格缩进时，它才会生效。

AlwaysBreakBeforeMultilineStrings: true
# ^^^^^^

# vvvvvv
# No.[23], AlwaysBreakTemplateDeclarations (BreakTemplateDeclarationsStyle)
# 要使用的模板声明中断样式。
# 可能的值：
# No: 不要在模板声明后中断。
# MultiLine: 在模板声明后中断。
# Yes: 总是在模板声明后中断。

AlwaysBreakTemplateDeclarations: Yes
# ^^^^^^

# vvvvvv
# No.[24], AttributeMacros (List of Strings)
# 字符串的向量，应该被解释为属性/限定符而不是标识符。这对于语言扩展或静态分析器注释很有用。

AttributeMacros: [__capability, __output, __ununsed]
# ^^^^^^

# vvvvvv
# No.[25], BinPackArguments (Boolean)
# 如果为 true，则将函数参数放在一行上，如果它们适合的话。
# 如果为 false，则函数调用的参数要么都在同一行，要么各一行。

BinPackArguments: false
# ^^^^^^

# vvvvvv
# No.[26], BinPackParameters (Boolean)
# 如果为 true，则将函数参数放在一行上，如果它们适合的话。
# 如果为 false，则函数声明的参数要么都在同一行，要么各一行。

BinPackParameters: false
# ^^^^^^

# vvvvvv
# No.[27], BitFieldColonSpacing (BitFieldColonSpacingStyle)
# 位字段冒号的间距样式。
# 可能的值：
# Both: 在冒号两边都有空格。
# None: 冒号两边都没有空格。
# Before: 冒号前有空格。
# After: 冒号后有空格。

BitFieldColonSpacing: After
# ^^^^^^

# vvvvvv
# No.[28], BraceWrapping (BraceWrappingFlags)
# 控制大括号的换行。
# 如果 BreakBeforeBraces 被设置为 Custom，使用这个来指定应该如何处理每个单独的大括号。否则，这将被忽略。

# Example of usage:
# BreakBeforeBraces: Custom
# BraceWrapping:
#     AfterCaseLabel: true
#     AfterClass: true
#     AfterControlStatement: Always
#     AfterEnum: true
#     AfterFunction: true
#     AfterNamespace: true
#     AfterStruct: true
#     AfterUnion: true
#     AfterExternBlock: true
#     BeforeCatch: true
#     BeforeElse: true
#     BeforeLambdaBody: true
#     BeforeWhile: true
#     IndentBraces: true
#     SplitEmptyFunction: true
#     SplitEmptyRecord: true
#     SplitEmptyNamespace: true
# ^^^^^^

# vvvvvv
# No.[29], BreakBeforeBinaryOperators (BinaryOperatorStyle)
# 控制二进制操作符的换行。
# 可能的值：
# None: 不要在二进制操作符前中断。
# NonAssignment: 仅在非赋值二进制操作符前中断。
# All: 在所有二进制操作符前中断。

BreakBeforeBinaryOperators: NonAssignment
# ^^^^^^

# vvvvvv
# No.[30], BreakBeforeBraces (BraceBreakingStyle)
# 控制大括号的换行。
# 可能的值：
# Attach: 始终将大括号附加到周围的上下文。
# Linux: 与 Attach 类似，但在函数、名称空间和类定义的大括号前中断。
# Mozilla: 与 Attach 类似，但在枚举、函数和记录定义的大括号前中断。
# Stroustrup: 与 Attach 类似，但在函数定义、catch 和 else 之前断开。
# Allman: 总是在大括号之前中断。
# Whitesmiths: 像 Allman 一样，但总是用大括号缩进和用大括号对齐代码。
# GNU: 总是在大括号之前中断，并在控制语句的大括号中添加额外的缩进，而不是在类、函数或其他定义的大括号中。
# WebKit: 类似于 Attach，但是在函数之前中断。
# Custom: 在 BraceWrapping 中配置每个单独的大括号。

BreakBeforeBraces: Allman
# ^^^^^^

# vvvvvv
# No.[31], BreakBeforeConceptDeclarations (Boolean)
# 如果为 true，则在概念声明之前中断。

BreakBeforeConceptDeclarations: true
# ^^^^^^

# vvvvvv
# No.[32], BreakBeforeTernaryOperators (Boolean)
# 如果为 true，则在三元操作符之前中断。

BreakBeforeTernaryOperators: true
# ^^^^^^

# vvvvvv
# No.[33], BreakConstructorInitializers (BreakConstructorInitializersStyle)
# 控制构造函数初始化列表的换行。
# 可能的值：
# BeforeColon: 在冒号之前和逗号之后中断构造函数初始化式。
# BeforeComma: 在冒号和逗号之前中断构造函数初始化式，并将逗号与冒号对齐。
# AfterColon: 在冒号和逗号后中断构造函数初始化式。

BreakConstructorInitializers: AfterColon
# ^^^^^^

# vvvvvv
# No.[34], BreakInheritanceList (BreakInheritanceListStyle)
# 控制继承列表的换行。
# 可能的值：
# BeforeColon: 在冒号之前和逗号之后中断继承列表。
# BeforeComma: 在冒号和逗号之前中断继承列表，并将逗号与冒号对齐。
# AfterColon: 在冒号和逗号后中断继承列表。

BreakInheritanceList: AfterColon
# ^^^^^^

# vvvvvv
# No.[35], BreakStringLiterals (Boolean)
# 如果为 true，则在字符串文字中断。

BreakStringLiterals: true
# ^^^^^^

# vvvvvv
# No.[36], ColumnLimit (Unsigned)
# 一行的最大长度。列限制为 0 意味着没有列限制。在这种情况下，clang-format 将在语句中尊重输入的断行决定，除非它们与其他规则相抵触。

ColumnLimit: 120
# ^^^^^^

# vvvvvv
# No.[37], CommentPragmas (String)
# 一个正则表达式，它描述具有特殊含义的注释，不应该将注释分成行或以其他方式更改注释。这会影响某些样式选项的默认值。

CommentPragmas: '^ FOOBAR pragma:'
# ^^^^^^

# vvvvvv
# No.[38], CompactNamespaces (Boolean)
# 如果为 true，连续的名称空间声明将在同一行上。如果为 false，则每个名称空间都声明在一个新的行中。

CompactNamespaces: false
# ^^^^^^

# vvvvvv
# No.[39], ConstructorInitializerIndentWidth (Unsigned)
# 构造函数初始化列表的缩进宽度。

ConstructorInitializerIndentWidth: 0
# ^^^^^^

# vvvvvv
# No.[40], ContinuationIndentWidth (Unsigned)
# 换行后的缩进宽度。

ContinuationIndentWidth: 4
# ^^^^^^

# vvvvvv
# No.[41], Cpp11BracedListStyle (Boolean)
# 如果为 true，将带大括号的列表格式化为最适合 C++11 带大括号的列表。
# 重要区别：
# 括号内没有空格。
# 在右括号之前不能换行。
# 使用延续缩进，而不是使用块缩进。
# 基本上，带大括号的 C++11 列表的格式与函数调用在其位置上的格式完全相同。如果带括号的列表跟在一个名称后面(例如，类型名或变量名)，clang-format 的格式就好像 {} 是带有该名称的函数调用的圆括号一样。如果没有名称，则假定名称长度为零。

Cpp11BracedListStyle: false
# ^^^^^^

# vvvvvv
# No.[42], DeriveLineEnding (Boolean)
# 分析格式化文件中最常用的行结束符(\r\n或\n)。只有当没有派生项时，UseCRLF 才用作后备。

DeriveLineEnding: false
# ^^^^^^

# vvvvvv
# No.[43], DerivePointerAlignment (Boolean)
# 如果为 true，分析格式化文件，以确定最常见的 & 和 * 对齐方式。指针和引用对齐样式将根据文件中找到的首选项进行更新。然后，PointerAlignment 仅用作后备。

DerivePointerAlignment: true
# ^^^^^^

# vvvvvv
# No.[44], DisableFormat (Boolean)
# 如果为 true，则不要格式化文件。

DisableFormat: false
# ^^^^^^

# vvvvvv
# No.[45], EmptyLineAfterAccessModifier (EmptyLineAfterAccessModifierStyle)
# 定义何时在访问修饰符后放置空行。 EmptyLineBeforeAccessModifier 配置处理两个访问修饰符之间的空行数。
# 可能的值：
# Never: 从不在访问修饰符后放置空行。
# Always: 总是在访问修饰符后放置空行。
# Leave: 在访问修饰符后放置空行，但在类成员之间不放置空行。

EmptyLineAfterAccessModifier: Always
# ^^^^^^

# vvvvvv
# No.[46], EmptyLineBeforeAccessModifier (EmptyLineBeforeAccessModifierStyle)
# 定义何时在访问修饰符前放置空行。 EmptyLineAfterAccessModifier 配置处理两个访问修饰符之间的空行数。
# 可能的值：
# Never: 从不在访问修饰符前放置空行。
# Always: 总是在访问修饰符前放置空行。
# Leave: 在访问修饰符前放置空行，但在类成员之间不放置空行。
# LogicalBlock: 在访问修饰符前放置空行，但在逻辑块之间不放置空行。

EmptyLineBeforeAccessModifier: Always
# ^^^^^^

# vvvvvv
# No.[47], ExperimentalAutoDetectBinPacking (Boolean)
# 如果为 true, clang-format 将检测函数调用和定义是否每行使用一个参数进行格式化。
# 每个调用都可以被包含，每行或不确定。如果它是不确定的，例如完全在一行上，但需要做出决定，clang-format 分析输入文件中是否有其他包含情况，并相应地采取行动。
# 这是一个实验性的标志，它可能会消失或被重命名。不要在配置文件中使用它，等等。使用时自负风险。

ExperimentalAutoDetectBinPacking: true
# ^^^^^^

# vvvvvv
# No.[48], FixNamespaceComments (Boolean)
# 如果为 true, clang-format 将为短名称空间添加缺失的名称空间结束注释，并修复无效的现有名称空间。短的由 ShortNamespaceLines 控制。

FixNamespaceComments: true
# ^^^^^^

# vvvvvv
# No.[49], ForEachMacros (List of Strings)
# 字符串的向量，应该被解释为 foreach 宏而不是标识符或函数调用。这对于语言扩展或静态分析器注释很有用。

ForEachMacros: [EACH, FOR_EACH， RANGES_FOR, FOREACH]
# ^^^^^^

# vvvvvv
# No.[50], IfMacros (List of Strings)
# 字符串的向量，应该被解释为 if 宏而不是标识符或函数调用。这对于语言扩展或静态分析器注释很有用。

IfMacros: [IF, IF_NOT, IF_NULL, IF_NOT_NULL]
# ^^^^^^

# vvvvvv
# No.[51], IncludeBlocks (IncludeBlocksStyle)
# 根据这个值，可以将多个 #include 块按类别排序。
# 可能的值：
# Preserve: 分别对每个 #include 块进行排序。
# Regroup: 将多个 #include 块合并在一起，并按一个排序。然后根据类别优先级分组。参考 IncludeCategories。
# Merge: 将多个 #include 块合并在一起，并按一个排序。

IncludeBlocks: Regroup
# ^^^^^^

# vvvvvv
# No.[52], IncludeCategories (List of IncludeCategories)
# 正则表达式表示用于排序 #include 的不同 #include 类别。
# 支持 POSIX 扩展正则表达式。
# 这些正则表达式按顺序匹配包含的文件名(包括 <>或 "")。分配属于第一个匹配正则表达式的值，#include 首先根据类别编号递增排序，然后在每个类别内按字母顺序排序。
# 如果所有正则表达式都不匹配，则 INT_MAX 被分配为类别。源文件的主标题自动获得类别 0。因此它通常保存在 #include (https://llvm.org/docs/CodingStandards.html#include-style) 的开头。然而，如果你有某些总是需要优先的头，你也可以分配负优先级。
# 当 IncludeBlocks = IBS_Regroup 时，可以使用第三个可选字段 SortPriority 来定义 #include 应该被排序的优先级。Priority 的值定义了 #include 块的顺序，也允许对不同优先级的 #include 块进行分组。如果没有分配 SortPriority，则将其设置为 Priority 的默认值。
# 每个正则表达式都可以用大小写敏感字段标记为区分大小写，但默认情况下它不是。

IncludeCategories:
    - Regex: '^"(llvm|llvm-c|clang|clang-c)/'
      Priority: 2
      SortPriority: 2
      CaseSensitive: true
    - Regex: '^(<|"(gtest|gmock|isl|json)/)'
      Priority: 3
    - Regex: '<[[:alnum:].]+>'
      Priority: 4
    - Regex: '.*'
      Priority: 1
      SortPriority: 0
# ^^^^^^

# vvvvvv
# No.[53], IncludeIsMainRegex (String)
# 指定在 file-to-main-include 映射中允许的后缀的正则表达式。
# 当猜测 #include 是否是 main include 时(为类别 0 赋值，见上面)，使用这个允许后缀的正则表达式到标题干。完成部分匹配，因此:
# "" 表示 “任意后缀”
# "$" 表示 “没有后缀”
# 例如，如果配置为 (_test)?$，则头文件 a.h 将被视为 a.cc 和 a_test.cc 中的 main。

IncludeIsMainRegex: '((_test)|(Test))?$'
# ^^^^^^

# vvvvvv
# No.[54], IncludeIsMainSourceRegex (String)
# 为在 file-to-main-include 映射中允许被视为 main 的格式化文件指定一个正则表达式。
# 默认情况下，只有当文件以: .c，.cc，.cpp，.c++，.cxx，.m 或 .mm 扩展名结束时，clang-format才会将文件视为 main。对于这些文件，会猜测 main include(要分配类别0，参见上面)。这个配置选项允许附加后缀和扩展名的文件被视为main。
# 例如，如果这个选项被配置为 (Impl\.hpp)$，那么一个文件 ClassImpl.hpp 被认为是main(除了 Class.c、Class.cc、Class.cpp 等)和 main include file 逻辑将被执行(稍后阶段还将使用 IncludeIsMainRegex 设置)。如果不设置此选项，ClassImpl.hpp 不会把主要的包含文件放在任何其他包含文件之前。

IncludeIsMainSourceRegex: ''
# ^^^^^^

# vvvvvv
# No.[55], IndentAccessModifiers (Boolean)
# 指定访问修饰符是否应该有自己的缩进级别。
# 当为 false 时，访问修饰符相对于记录成员缩进(或退缩)，表示 AccessModifierOffset。记录成员缩进比记录低一级。当为 true 时，访问修饰符将获得自己的缩进级别。因此，记录成员总是比记录缩进 2 级，而不管是否存在访问修饰符。忽略 AccessModifierOffset 的值。

IndentAccessModifiers: false
# ^^^^^^

# vvvvvv
# No.[56], IndentCaseBlocks (Boolean)
# 缩进 case 标签阻塞 case 标签的一级。
# 当为 false 时，case 标签后面的块使用与 case 标签相同的缩进级别，将 case 标签视为if语句。当为 true 时，该块作为范围块缩进。

IndentCaseBlocks: false
# ^^^^^^

# vvvvvv
# No.[57], IndentCaseLabels (Boolean)
# 缩进 case 标记 switch 语句的一个级别。
# 当为 false 时，使用与 switch 语句相同的缩进级别。switch 语句体总是比 case 标签缩进一级( case 标签后面的第一个块除外，它本身会缩进代码——除非启用了 IndentCaseBlocks)。

IndentCaseLabels: true
# ^^^^^^

# vvvvvv
# No.[58], IndentExternBlock (IndentExternBlockStyle)
# 控制 extern "C" { ... } 的缩进（即 IndentExternBlockStyle 是 extern 块的缩进类型）。
# 可能的值：
# AfterExternBlock: 向后兼容 AfterExternBlock 的缩进。
# Indent: 缩进外部块。
# NoIndent: 不要缩进外部块。

IndentExternBlock: Indent
# ^^^^^^

# vvvvvv
# No.[59], IndentGotoLabels (Boolean)
# 缩进 goto 标签。
# 当为 false 时，goto 标签被推到最左侧。

IndentGotoLabels: false
# ^^^^^^

# vvvvvv
# No.[60], IndentPPDirectives (PPDirectiveIndentStyle)
# 控制预处理指令的缩进。
# 可能的值：
# None: 不要缩进预处理指令。
# AfterHash: 在 # 之后缩进预处理指令。
# BeforeHash: 在 # 之前缩进预处理指令。

IndentPPDirectives: BeforeHash
# ^^^^^^

# vvvvvv
# No.[61], IndentRequires (Boolean)
# 如果为 true，则缩进 requires 子句。

IndentRequires: true
# ^^^^^^

# vvvvvv
# No.[62], IndentWidth (Unsigned)
# 缩进宽度。

IndentWidth: 4
# ^^^^^^

# vvvvvv
# No.[63], IndentWrappedFunctionNames (Boolean)
# 如果为 true，则缩进包装函数名称。

IndentWrappedFunctionNames: true
# ^^^^^^

# vvvvvv
# No.[64], InsertTrailingCommas (TrailingCommaStyle)
# 如果设置为 TCS_Wrapped，则会在跨多行换行的容器文本(数组和对象)中插入末尾的逗号。它目前仅对 JavaScript 可用，并在默认情况下禁用 TCS_None。InsertTrailingCommas 不能与 BinPackArguments 一起使用，因为插入逗号会禁用包装。
# 可能的值：
# Wrapped: 在包装在多行中的括号字面值中插入尾随逗号。请注意，这在概念上与装箱不兼容，因为末尾的逗号被用作指示容器应该每行格式化(即不包含)。因此，插入末尾逗号会抵消括号的作用。
# None: 不要插入末尾的逗号。

InsertTrailingCommas: None
# ^^^^^^

# vvvvvv
# No.[65], KeepEmptyLinesAtTheStartOfBlocks (Boolean)
# 如果为 true，则在块的开头保留空行。

KeepEmptyLinesAtTheStartOfBlocks: false
# ^^^^^^

# vvvvvv
# No.[66], LambdaBodyIndentation (LambdaBodyIndentationKind)
# lambda 主体的缩进样式。（默认）导致 lambda 主体相对于签名的缩进级别缩进一个额外的级别。OuterScope 强制 lambda 主体相对于包含 lambda 签名的父作用域缩进一个额外的级别。 对于回调繁重的代码，将签名缩进两级并使用 OuterScope 可能会提高可读性。KJ 风格（https://github.com/capnproto/capnproto/blob/master/kjdoc/style-guide.md）指南需要 OuterScope。
# 可能的值：
# Signature: lambda 主体相对于签名缩进一个额外的级别。
# OuterScope: lambda 主体相对于包含 lambda 签名的父作用域缩进一个额外的级别。

LambdaBodyIndentation: Signature
# ^^^^^^

# vvvvvv
# No.[67], Language (LanguageKind)
# 语言，这种格式风格是针对的。
# 可能的值：
# Cpp: C、C++。
# CS: C#。
# Java: Java。
# JavaScript: JavaScript。
# ObjC: Objective-C。
# Proto: Protocol Buffers。
# TableGen: TableGen。
# TextProto: Text Protocol Buffers。
# None: 无。

Language: Cpp
# ^^^^^^

# vvvvvv
# No.[68], MacroBlockBegin (String)
# 匹配开始块的宏的正则表达式。

MacroBlockBegin: "^MAP_BEGIN|\
    TABLE_HEAD$"
# ^^^^^^

# vvvvvv
# No.[69], MacroBlockEnd (String)
# 匹配结束块的宏的正则表达式。

MacroBlockEnd: "^\
    MAP_END|\
    TABLE_.*_END$"
# ^^^^^^

# vvvvvv
# No.[70], MaxEmptyLinesToKeep (Unsigned)
# 要保留的最大连续空行数。

MaxEmptyLinesToKeep: 3
# ^^^^^^

# vvvvvv
# No.[71], NamespaceIndentation (NamespaceIndentationKind)
# 控制名称空间的缩进。
# 可能的值：
# None: 不要缩进名称空间。
# Inner: 缩进名称空间内部。
# All: 缩进名称空间内部和外部。

NamespaceIndentation: All
# ^^^^^^

# vvvvvv
# No.[72], NamespaceMacros (List of Strings)
# 字符串的向量，应该被解释为名称空间宏而不是标识符。这对于语言扩展或静态分析器注释很有用。

NamespaceMacros: [NAMESPACE, BEGIN_NAMESPACE, END_NAMESPACE, BEGIN_NAMESPACE_ZHANG, END_NAMESPACE_ZHANG]
# ^^^^^^

# vvvvvv
# No.[73], PPIndentWidth (Integer)
# 用于缩进预处理器语句的列数。 当设置为 -1（默认）时，IndentWidth 也用于预处理器语句。

PPIndentWidth: -1
# ^^^^^^

# vvvvvv
# No.[74], PackConstructorInitializers (PackConstructorInitializersStyle)
# 要使用的包构造函数初始值设定项样式。
# 可能的值：
# Never: 始终将每个构造函数初始化器放在自己的行上。
# BinPack: Bin-pack 构造函数初始值设定项。
# CurrentLine: 如果合适，将所有构造函数初始值设定项放在当前行。 否则，将每个都放在自己的行上。
# NextLine: 与 PCIS_CurrentLine 相同，但如果所有构造函数初始值设定项都不适合当前行，则尝试将它们放在下一行。

PackConstructorInitializers: NextLine
# ^^^^^^

# vvvvvv
# No.[75], PenaltyBreakAssignment (Unsigned)
# 突破赋值运算符的补偿。

PenaltyBreakAssignment: 2
# ^^^^^^

# vvvvvv
# No.[76], PenaltyBreakBeforeFirstCallParameter (Unsigned)
# call( 后中断函数调用的补偿。

PenaltyBreakBeforeFirstCallParameter: 19
# ^^^^^^

# vvvvvv
# No.[77], PenaltyBreakComment (Unsigned)
# 注释中引入的每个换行符的补偿。

PenaltyBreakComment: 300
# ^^^^^^

# vvvvvv
# No.[78], PenaltyBreakFirstLessLess (Unsigned)
# 在第一个 << 之前中断的补偿。

PenaltyBreakFirstLessLess: 120
# ^^^^^^

# vvvvvv
# No.[79], PenaltyBreakString (Unsigned)
# 在字符串文字中引入的每个换行符的补偿。

PenaltyBreakString: 1000
# ^^^^^^

# vvvvvv
# No.[80], PenaltyBreakTemplateDeclaration (Unsigned)
# 模板声明后中断的补偿。

PenaltyBreakTemplateDeclaration: 10
# ^^^^^^

# vvvvvv
# No.[81], PenaltyExcessCharacter (Unsigned)
# 列限制之外的每个字符的补偿。

PenaltyExcessCharacter: 1000000
# ^^^^^^

# vvvvvv
# No.[82], PenaltyIndentedWhitespace (Unsigned)
# 空格缩进的每个字符的补偿（相对于前导非空格列计算）。

PenaltyIndentedWhitespace: 0
# ^^^^^^

# vvvvvv
# No.[83], PenaltyReturnTypeOnItsOwnLine (Unsigned)
# 将函数的返回类型放在它自己的行上的补偿。

PenaltyReturnTypeOnItsOwnLine: 60
# ^^^^^^

# vvvvvv
# No.[84], PointerAlignment (PointerAlignmentStyle)
# 控制指针的对齐。
# 可能的值：
# Left: 指针左对齐。
# Right: 指针右对齐。
# Middle: 指针居中对齐。

PointerAlignment: Left
# ^^^^^^

# vvvvvv
# No.[85], QualifierAlignment (QualifierAlignmentStyle)
# 排列说明符和限定符的不同方式（例如 const/volatile）。
# Waring
# 将 QualifierAlignment 设置为 Leave 以外的其他内容，可能会导致错误的代码格式，这是由于 clang-format 缺乏完整的语义信息而做出的错误决定。因此，应格外小心地审查使用此选项所做的代码更改。
# 可能的值：
# Left: 说明符和限定符左对齐。
# Right: 说明符和限定符右对齐。
# Custom: 在 QualifierAlignment 对象中配置每个单独的说明符和限定符。
# Leave: 不要将说明符/限定符更改为左对齐或右对齐（默认）。

QualifierAlignment: Custom
QualifierOrder: [static, constexpr, inline, const, restrict, volatile, type]
# ^^^^^^

# vvvvvv
# No.[86], RawStringFormats (List of RawStringFormats)
# 定义在原始字符串中检测支持的语言代码块的提示。
# 带有匹配的分隔符或包含匹配的函数名的原始字符串将根据 .clang-format 文件中定义的语言的样式进行重新格式化，假设该语言是指定的语言。如果在.clang-format 文件中没有为特定语言定义样式，则使用 BasedOnStyle 给出的预定义样式。如果没有找到 BasedOnStyle，则格式化基于 llvm 风格。匹配分隔符优先于匹配的封闭函数名，以确定原始字符串内容的语言。
# 如果指定了规范分隔符，同一语言中出现的其他分隔符将尽可能更新为规范。
# 每种语言最多应该有一个规范，每个分隔符和包围函数不应该出现在多个规范中。

# forexample, the following configuration:
# RawStringFormats:
#   - Language: TextProto
#       Delimiters:
#         - 'pb'
#         - 'proto'
#       EnclosingFunctions:
#         - 'PARSE_TEXT_PROTO'
#       BasedOnStyle: google
#   - Language: Cpp
#       Delimiters:
#         - 'cc'
#         - 'cpp'
#       BasedOnStyle: llvm
#       CanonicalDelimiter: 'cc'
# ^^^^^^

# vvvvvv
# No.[87], ReferenceAlignment (ReferenceAlignmentStyle)
# 引用对齐样式（覆盖引用的 PointerAlignment）。
# 可能的值：
# Left: 引用左对齐。
# Right: 引用右对齐。
# Middle: 引用居中对齐。
# Pointer: 使用 PointerAlignment 的值。

ReferenceAlignment: Pointer
# ^^^^^^

# vvvvvv
# No.[88], ReflowComments (Boolean)
# 如果为 true，则重新格式化注释以适应列限制。

ReflowComments: false
# ^^^^^^

# vvvvvv
# No.[89], ShortNamespaceLines (Unsigned)
# 短名称空间所跨的未换行的最大行数。默认为 1。
# 这通过计算未换行的行(即不包含打开或关闭名称空间大括号)来确定短名称空间的最大长度，并使 FixNamespaceComments 省略为这些行添加的结束注释。

ShortNamespaceLines: 1
# ^^^^^^

# vvvvvv
# No.[90], SortIncludes (SortIncludesOptions)
# 控制 clang-format 是否以及如何排序 #include。如果没有，则包含永远不会排序。如果不区分大小写，则包含以ascii或不区分大小写的方式排序。如果区分大小写，则包含按字母或区分大小写的方式排序。
# 可能的值：
# Never: 包含永远不会排序。
# CaseSensitive: include 以大小写敏感的方式排序。
# CaseInsensitive: include 以不区分字母或大小写的方式排序。

SortIncludes: CaseInsensitive
# ^^^^^^

# vvvvvv
# No.[91], SortUsingDeclarations (Boolean)
# 如果为 true，clang-format 将使用声明进行排序。
# 使用声明的顺序定义如下:使用 :: 分隔字符串并丢弃任何初始化的空字符串。每个列表的最后一个元素是一个非命名空间名称;其他的都是命名空间名称。按字典顺序对名称列表进行排序，其中个人名称的排序顺序是所有非名称空间名称出现在所有名称空间名称之前，并且在这些组中，名称不区分大小写。

SortUsingDeclarations: true
# ^^^^^^

# vvvvvv
# No.[92], SpaceAfterCStyleCast (Boolean)
# 如果为 true，则在 C 风格的类型转换后添加空格。

SpaceAfterCStyleCast: false
# ^^^^^^

# vvvvvv
# No.[93], SpaceAfterLogicalNot (Boolean)
# 如果为 true，则在逻辑非操作符（!）后添加空格。

SpaceAfterLogicalNot: false
# ^^^^^^

# vvvvvv
# No.[94], SpaceAfterTemplateKeyword (Boolean)
# 如果为 true，则在模板关键字后添加空格。

SpaceAfterTemplateKeyword: true
# ^^^^^^

# vvvvvv
# No.[95], SpaceAroundPointerQualifiers (SpaceAroundPointerQualifiersStyle)
# 定义在何种情况下在指针限定符之前或之后放置空格
# 可能的值：
# Default: 不要确保指针限定符周围有空格，而是使用 PointerAlignment。
# Before: 确保在指针限定符之前有空格。
# After: 确保在指针限定符后有空格。
# Both:  确保在指针限定符的前后都有空格。

SpaceAroundPointerQualifiers: Default
# ^^^^^^

# vvvvvv
# No.[96], SpaceBeforeAssignmentOperators (Boolean)
# 如果为 true，则在赋值操作符之前添加空格。

SpaceBeforeAssignmentOperators: true
# ^^^^^^

# vvvvvv
# No.[97], SpaceBeforeCaseColon (Boolean)
# 如果为 true，则在 case 标签的冒号之前添加空格。

SpaceBeforeCaseColon: false
# ^^^^^^

# vvvvvv
# No.[98], SpaceBeforeCpp11BracedList (Boolean)
# 如果为 true，则在用于初始化对象的 C++11 大括号列表之前插入一个空格(在前面的标识符或类型之后)。

SpaceBeforeCpp11BracedList: true
# ^^^^^^

# vvvvvv
# No.[99], SpaceBeforeCtorInitializerColon (Boolean)
# 如果为 true，则在构造函数初始化列表的冒号之前添加空格。

SpaceBeforeCtorInitializerColon: false
# ^^^^^^

# vvvvvv
# No.[100], SpaceBeforeInheritanceColon (Boolean)
# 如果为 true，则在继承列表的冒号之前添加空格。

SpaceBeforeInheritanceColon: false
# ^^^^^^

# vvvvvv
# No.[101], SpaceBeforeParens (SpaceBeforeParensOptions)
# 控制在左圆括号之前放置空格的情况。
# 可能的值：
# Never: 从不在左圆括号之前放置空格。
# ControlStatements: 在控制语句( if、for、while 等)的左圆括号之前放置空格。
# ControlStatementsExceptForEachMacros: 在控制语句( if、for、while 等)的左圆括号之前放置空格，但不在 for 的左圆括号之前放置空格。
# NonEmptyParentheses: 在非空圆括号的左圆括号之前放置空格。
# Always: 总是在左圆括号之前放置空格。
# Custom: 使用 SpaceBeforeParensOptions 来指定应如何处理括号大小写前的每个单独的空格。

SpaceBeforeParens: ControlStatements
# ^^^^^^

# vvvvvv
# No.[102], SpaceBeforeParensOptions (SpaceBeforeParensCustom)
# 控制括号前的单个空格。
# 如果 SpaceBeforeParens 设置为 Custom，则使用它来指定应如何处理括号大小写前的每个单独的空格。否则，这将被忽略。

SpaceBeforeParensOptions:
    AfterControlStatements: false
    AfterForeachMacros: false
    AfterFunctionDefinitionName: false
    AfterFunctionDeclarationName: false
    AfterIfMacros: false
    AfterOverloadedOperator: false
    AfterRequiresInClause: false
    AfterRequiresInExpression: false
    BeforeNonEmptyParentheses: false
# ^^^^^^

# vvvvvv
# No.[103], SpaceBeforeRangeBasedForLoopColon (Boolean)
# 如果为 true，则在范围 for 循环的冒号之前添加空格。

SpaceBeforeRangeBasedForLoopColon: false
# ^^^^^^

# vvvvvv
# No.[104], SpaceBeforeSquareBrackets (Boolean)
# 如果为 true，空格将在 [ 之前。不受影响。只有第一个 [ 会被加一个空格。

SpaceBeforeSquareBrackets: false
# ^^^^^^

# vvvvvv
# No.[105], SpaceInEmptyBlock (Boolean)
# 如果为 true，则在空块中添加空格。

SpaceInEmptyBlock: false
# ^^^^^^

# vvvvvv
# No.[106], SpaceInEmptyParentheses (Boolean)
# 如果为 true，则在空括号中添加空格。

SpaceInEmptyParentheses: false
# ^^^^^^

# vvvvvv
# No.[107], SpacesBeforeTrailingComments (Unsigned)
# 尾行注释(// -注释)之前的空格数。
# 这不会影响末尾的块注释(/* -注释)，因为这些注释通常有不同的使用模式和一些特殊情况。

SpacesBeforeTrailingComments: 2
# ^^^^^^

# vvvvvv
# No.[108], SpacesInAngles (SpacesInAnglesStyle)
# 用于模板参数列表的 SpacesInAnglesStyle。
# 可能的值：
# Leave: 如果存在空格，则在 < 之后和之前保留一个空格。 选项标准：Cpp03 优先。
# Never: 删除 < 之后和 > 之前的空格。
# Always: 在 < 之后和 > 之前添加空格。

SpacesInAngles: Never
# ^^^^^^

# vvvvvv
# No.[109], SpacesInCStyleCastParentheses (Boolean)
# 如果为 true，则在 C 风格的类型转换的括号中添加空格。

SpacesInCStyleCastParentheses: false
# ^^^^^^

# vvvvvv
# No.[110], SpacesInConditionalStatement (Boolean)
# 如果为 true，则在 if/for/switch/while 条件周围插入空格。

SpacesInConditionalStatement: false
# ^^^^^^

# vvvvvv
# No.[111], SpacesInContainerLiterals (Boolean)
# 如果为 true，则在容器字面量(例如 ObjC 和 Javascript 数组和 dict 字面量)中插入空格。

SpacesInContainerLiterals: true
# ^^^^^^

# vvvvvv
# No.[112], SpacesInLineCommentPrefix (SpacesInLineComment)
# 一行注释的开头允许有多少个空格。要禁用最大值，请将其设置为 -1，但最大值优先于最小值。

SpacesInLineCommentPrefix:
    Minimum: 1
    Maximum: -1
# ^^^^^^

# vvvvvv
# No.[113], SpacesInParentheses (Boolean)
# 如果为 true，则在括号内插入空格。

SpacesInParentheses: false
# ^^^^^^

# vvvvvv
# No.[114], SpacesInSquareBrackets (Boolean)
# 如果为 true，将在 [ 和之前 ] 后面插入空格。没有参数或未指定大小的数组声明的匿名函数将不受影响。

SpacesInSquareBrackets: true
# ^^^^^^

# vvvvvv
# No.[115], Standard (LanguageStandard)
# 解析和格式化与这个标准兼容的 C++ 结构。
# 可能的值：
# Cpp03: 解析和格式化为 C++03。Cpp03 是 c++03 的一个已弃用别名
# Cpp11: 解析和格式化为 C++11。
# Cpp14: 解析和格式化为 C++14。
# Cpp17: 解析和格式化为 C++17。
# Cpp20: 解析和格式化为 C++20。
# Latest: 使用最新支持的语言版本进行解析和格式化。Cpp11 是最新的一个已弃用别名。
# Auto: 自动检测输入文件的标准。

Standard: Latest
# ^^^^^^

# vvvvvv
# No.[116], StatementAttributeLikeMacros (List of Strings)
# 在语句前面被忽略的宏，就像它们是一个属性一样。这样它们就不会被解析为标识符。

StatementAttributeLikeMacros: []
# ^^^^^^

# vvvvvv
# No.[117], StatementMacros (List of Strings)
# 宏的一个向量，应该被解释为完整的语句。
# 典型的宏是表达式，需要添加分号; 有时情况并非如此，这允许 clang-format 能够识别这种情况。

StatementMacros: []
# ^^^^^^

# vvvvvv
# No.[118], TabWidth (Unsigned)
# 制表符宽度。

TabWidth: 4
# ^^^^^^

# vvvvvv
# No.[119], TypenameMacros (List of Strings)
# 宏的一个向量，它应该被解释为类型声明而不是函数调用。

TypenameMacros: []
# ^^^^^^

# vvvvvv
# No.[120], UseCRLF (Boolean)
# 用 \r\n 代替 \n 换行。如果 (DeriveLineEnding)(../DeriveLineEnding) 为 true，也用作回退。

UseCRLF: false
# ^^^^^^

# vvvvvv
# No.[121], UseTab (UseTabStyle)
# 控制是否使用制表符。
# 可能的值：
# Never: 从不使用制表符。
# ForIndentation: 仅在缩进级别中使用制表符。
# ForContinuationAndIndentation: 用制表符填充所有的前导空格，并在一行中使用空格进行对齐(例如连续的赋值和声明)。
# AlignWithSpaces: 使用制表符进行行延续和缩进，使用空格进行对齐。
# Always: 当需要填补至少从一个制表位到下一个制表位的空白时，使用制表位。

UseTab: Always
# ^^^^^^

# vvvvvv
# No.[122], WhitespaceSensitiveMacros (List of Strings)
# 宏的一个向量，应该被解释为敏感于空格的宏。

WhitespaceSensitiveMacros:
    [STRINGIZE, PP_STRINGIZE, STRINGIZE, PP_STRINGIZE, BOOST_PP_STRINGIZE, NS_SWIFT_NAME, CF_SWIFT_NAME]
# ^^^^^^
